"""
Vulnerability Scanner for Aictive Platform
Provides comprehensive security scanning for dependencies, containers, and infrastructure.
"""
import os
import json
import subprocess
import asyncio
import re
import yaml
from typing import Dict, List, Optional, Any, Set, Tuple
from datetime import datetime, timedelta
from enum import Enum
from dataclasses import dataclass, field
from pathlib import Path
import hashlib
import tempfile
import aiohttp
import aiofiles
from packaging import version
import docker
import structlog
from collections import defaultdict

logger = structlog.get_logger()


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"
    
    @property
    def score_range(self) -> Tuple[float, float]:
        """Get CVSS score range for severity"""
        ranges = {
            self.CRITICAL: (9.0, 10.0),
            self.HIGH: (7.0, 8.9),
            self.MEDIUM: (4.0, 6.9),
            self.LOW: (0.1, 3.9),
            self.INFO: (0.0, 0.0)
        }
        return ranges[self]


class ScanType(Enum):
    """Types of security scans"""
    DEPENDENCY = "dependency"
    CONTAINER = "container"
    INFRASTRUCTURE = "infrastructure"
    CODE = "code"
    SECRETS = "secrets"
    CONFIGURATION = "configuration"


@dataclass
class Vulnerability:
    """Vulnerability information"""
    id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    cvss_score: Optional[float] = None
    cve_id: Optional[str] = None
    cwe_id: Optional[str] = None
    affected_component: str = ""
    affected_version: str = ""
    fixed_version: Optional[str] = None
    published_date: Optional[datetime] = None
    last_modified: Optional[datetime] = None
    references: List[str] = field(default_factory=list)
    exploit_available: bool = False
    patch_available: bool = False
    workaround: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            'id': self.id,
            'title': self.title,
            'description': self.description,
            'severity': self.severity.value,
            'cvss_score': self.cvss_score,
            'cve_id': self.cve_id,
            'cwe_id': self.cwe_id,
            'affected_component': self.affected_component,
            'affected_version': self.affected_version,
            'fixed_version': self.fixed_version,
            'published_date': self.published_date.isoformat() if self.published_date else None,
            'last_modified': self.last_modified.isoformat() if self.last_modified else None,
            'references': self.references,
            'exploit_available': self.exploit_available,
            'patch_available': self.patch_available,
            'workaround': self.workaround
        }


@dataclass
class ScanResult:
    """Security scan result"""
    scan_id: str
    scan_type: ScanType
    start_time: datetime
    end_time: Optional[datetime] = None
    target: str = ""
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def duration(self) -> Optional[timedelta]:
        """Get scan duration"""
        if self.end_time:
            return self.end_time - self.start_time
        return None
    
    @property
    def summary(self) -> Dict[str, int]:
        """Get vulnerability summary by severity"""
        summary = defaultdict(int)
        for vuln in self.vulnerabilities:
            summary[vuln.severity.value] += 1
        return dict(summary)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            'scan_id': self.scan_id,
            'scan_type': self.scan_type.value,
            'start_time': self.start_time.isoformat(),
            'end_time': self.end_time.isoformat() if self.end_time else None,
            'duration_seconds': self.duration.total_seconds() if self.duration else None,
            'target': self.target,
            'summary': self.summary,
            'vulnerabilities': [v.to_dict() for v in self.vulnerabilities],
            'errors': self.errors,
            'metadata': self.metadata
        }


class DependencyScanner:
    """Scan for vulnerabilities in dependencies"""
    
    def __init__(self):
        self.scanners = {
            'python': self._scan_python_deps,
            'javascript': self._scan_js_deps,
            'docker': self._scan_docker_deps
        }
    
    async def scan(self, project_path: Path) -> ScanResult:
        """Scan project dependencies"""
        scan_result = ScanResult(
            scan_id=self._generate_scan_id(),
            scan_type=ScanType.DEPENDENCY,
            start_time=datetime.utcnow(),
            target=str(project_path)
        )
        
        try:
            # Detect project type and run appropriate scanners
            if (project_path / "requirements.txt").exists() or (project_path / "Pipfile").exists():
                await self._scan_python_deps(project_path, scan_result)
            
            if (project_path / "package.json").exists():
                await self._scan_js_deps(project_path, scan_result)
            
            if (project_path / "Dockerfile").exists():
                await self._scan_docker_deps(project_path, scan_result)
            
        except Exception as e:
            scan_result.errors.append(f"Scan error: {str(e)}")
            logger.error(f"Dependency scan error: {e}")
        
        scan_result.end_time = datetime.utcnow()
        return scan_result
    
    async def _scan_python_deps(self, project_path: Path, scan_result: ScanResult):
        """Scan Python dependencies using safety and pip-audit"""
        # Using safety check
        try:
            # Generate requirements file if using Pipfile
            req_file = project_path / "requirements.txt"
            if not req_file.exists() and (project_path / "Pipfile").exists():
                subprocess.run(
                    ["pipenv", "requirements", ">", "requirements.txt"],
                    cwd=project_path,
                    shell=True,
                    capture_output=True
                )
            
            # Run safety check
            result = subprocess.run(
                ["safety", "check", "--json", "-r", str(req_file)],
                cwd=project_path,
                capture_output=True,
                text=True
            )
            
            if result.stdout:
                vulnerabilities = json.loads(result.stdout)
                for vuln in vulnerabilities:
                    scan_result.vulnerabilities.append(
                        Vulnerability(
                            id=f"SAFETY-{vuln.get('vulnerability_id', 'UNKNOWN')}",
                            title=vuln.get('advisory', ''),
                            description=vuln.get('description', ''),
                            severity=self._map_safety_severity(vuln.get('severity', '')),
                            cve_id=vuln.get('cve'),
                            affected_component=vuln.get('package_name', ''),
                            affected_version=vuln.get('analyzed_version', ''),
                            fixed_version=vuln.get('vulnerable_spec', '')
                        )
                    )
        except Exception as e:
            logger.warning(f"Safety check failed: {e}")
        
        # Using pip-audit
        try:
            result = subprocess.run(
                ["pip-audit", "--format", "json", "--desc"],
                cwd=project_path,
                capture_output=True,
                text=True
            )
            
            if result.stdout:
                audit_results = json.loads(result.stdout)
                for pkg_name, vulns in audit_results.items():
                    for vuln in vulns:
                        scan_result.vulnerabilities.append(
                            Vulnerability(
                                id=vuln.get('id', ''),
                                title=f"{pkg_name} - {vuln.get('id', '')}",
                                description=vuln.get('description', ''),
                                severity=self._map_pip_audit_severity(vuln),
                                affected_component=pkg_name,
                                affected_version=vuln.get('version', ''),
                                fixed_version=vuln.get('fixed_version')
                            )
                        )
        except Exception as e:
            logger.warning(f"pip-audit failed: {e}")
    
    async def _scan_js_deps(self, project_path: Path, scan_result: ScanResult):
        """Scan JavaScript dependencies using npm audit"""
        try:
            # Run npm audit
            result = subprocess.run(
                ["npm", "audit", "--json"],
                cwd=project_path,
                capture_output=True,
                text=True
            )
            
            if result.stdout:
                audit_data = json.loads(result.stdout)
                
                for advisory_id, advisory in audit_data.get('advisories', {}).items():
                    scan_result.vulnerabilities.append(
                        Vulnerability(
                            id=f"NPM-{advisory_id}",
                            title=advisory.get('title', ''),
                            description=advisory.get('overview', ''),
                            severity=self._map_npm_severity(advisory.get('severity', '')),
                            cve_id=advisory.get('cves', [None])[0],
                            cwe_id=advisory.get('cwe'),
                            affected_component=advisory.get('module_name', ''),
                            affected_version=advisory.get('vulnerable_versions', ''),
                            fixed_version=advisory.get('patched_versions'),
                            references=[advisory.get('url')] if advisory.get('url') else []
                        )
                    )
        except Exception as e:
            logger.warning(f"npm audit failed: {e}")
    
    async def _scan_docker_deps(self, project_path: Path, scan_result: ScanResult):
        """Scan Docker dependencies"""
        # This would integrate with tools like Trivy or Grype
        # For now, basic Dockerfile analysis
        dockerfile = project_path / "Dockerfile"
        if dockerfile.exists():
            async with aiofiles.open(dockerfile, 'r') as f:
                content = await f.read()
                
            # Check for security issues
            issues = self._analyze_dockerfile(content)
            for issue in issues:
                scan_result.vulnerabilities.append(issue)
    
    def _analyze_dockerfile(self, content: str) -> List[Vulnerability]:
        """Analyze Dockerfile for security issues"""
        vulnerabilities = []
        
        # Check for running as root
        if not re.search(r'USER\s+(?!root)', content):
            vulnerabilities.append(
                Vulnerability(
                    id="DOCKER-001",
                    title="Container runs as root",
                    description="Container runs with root privileges",
                    severity=VulnerabilitySeverity.HIGH,
                    affected_component="Dockerfile",
                    workaround="Add USER directive to run as non-root"
                )
            )
        
        # Check for latest tags
        if re.search(r'FROM\s+\S+:latest', content):
            vulnerabilities.append(
                Vulnerability(
                    id="DOCKER-002",
                    title="Using latest tag",
                    description="Using 'latest' tag can lead to unpredictable builds",
                    severity=VulnerabilitySeverity.MEDIUM,
                    affected_component="Dockerfile",
                    workaround="Use specific version tags"
                )
            )
        
        return vulnerabilities
    
    def _map_safety_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map safety severity to our enum"""
        mapping = {
            'critical': VulnerabilitySeverity.CRITICAL,
            'high': VulnerabilitySeverity.HIGH,
            'medium': VulnerabilitySeverity.MEDIUM,
            'low': VulnerabilitySeverity.LOW
        }
        return mapping.get(severity.lower(), VulnerabilitySeverity.MEDIUM)
    
    def _map_npm_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map npm severity to our enum"""
        return self._map_safety_severity(severity)
    
    def _map_pip_audit_severity(self, vuln: Dict) -> VulnerabilitySeverity:
        """Map pip-audit severity based on CVSS score"""
        cvss = vuln.get('cvss_score', 0)
        if cvss >= 9.0:
            return VulnerabilitySeverity.CRITICAL
        elif cvss >= 7.0:
            return VulnerabilitySeverity.HIGH
        elif cvss >= 4.0:
            return VulnerabilitySeverity.MEDIUM
        else:
            return VulnerabilitySeverity.LOW
    
    def _generate_scan_id(self) -> str:
        """Generate unique scan ID"""
        return hashlib.sha256(
            f"{datetime.utcnow().isoformat()}-{os.urandom(16).hex()}".encode()
        ).hexdigest()[:16]


class ContainerScanner:
    """Scan container images for vulnerabilities"""
    
    def __init__(self):
        self.docker_client = docker.from_env()
    
    async def scan_image(self, image_name: str) -> ScanResult:
        """Scan a container image"""
        scan_result = ScanResult(
            scan_id=self._generate_scan_id(),
            scan_type=ScanType.CONTAINER,
            start_time=datetime.utcnow(),
            target=image_name
        )
        
        try:
            # Use Trivy for container scanning
            await self._scan_with_trivy(image_name, scan_result)
            
            # Additional image analysis
            await self._analyze_image_layers(image_name, scan_result)
            
        except Exception as e:
            scan_result.errors.append(f"Container scan error: {str(e)}")
            logger.error(f"Container scan error: {e}")
        
        scan_result.end_time = datetime.utcnow()
        return scan_result
    
    async def _scan_with_trivy(self, image_name: str, scan_result: ScanResult):
        """Scan with Trivy vulnerability scanner"""
        try:
            # Run Trivy scan
            result = subprocess.run(
                ["trivy", "image", "--format", "json", "--quiet", image_name],
                capture_output=True,
                text=True
            )
            
            if result.stdout:
                trivy_results = json.loads(result.stdout)
                
                for target in trivy_results.get('Results', []):
                    for vuln in target.get('Vulnerabilities', []):
                        scan_result.vulnerabilities.append(
                            Vulnerability(
                                id=vuln.get('VulnerabilityID', ''),
                                title=vuln.get('Title', ''),
                                description=vuln.get('Description', ''),
                                severity=self._map_trivy_severity(vuln.get('Severity', '')),
                                cvss_score=self._extract_cvss_score(vuln),
                                cve_id=vuln.get('VulnerabilityID', '') if vuln.get('VulnerabilityID', '').startswith('CVE') else None,
                                affected_component=vuln.get('PkgName', ''),
                                affected_version=vuln.get('InstalledVersion', ''),
                                fixed_version=vuln.get('FixedVersion'),
                                references=vuln.get('References', [])
                            )
                        )
        except subprocess.CalledProcessError as e:
            logger.warning(f"Trivy scan failed: {e}")
        except FileNotFoundError:
            logger.warning("Trivy not found, skipping container scan")
    
    async def _analyze_image_layers(self, image_name: str, scan_result: ScanResult):
        """Analyze image layers for security issues"""
        try:
            image = self.docker_client.images.get(image_name)
            
            # Check image size
            size_mb = image.attrs['Size'] / (1024 * 1024)
            if size_mb > 1000:  # 1GB
                scan_result.vulnerabilities.append(
                    Vulnerability(
                        id="CONTAINER-001",
                        title="Large container image",
                        description=f"Image size is {size_mb:.2f}MB, consider optimization",
                        severity=VulnerabilitySeverity.LOW,
                        affected_component=image_name
                    )
                )
            
            # Check for sensitive files in history
            history = image.history()
            sensitive_patterns = [
                r'\.env', r'\.git', r'id_rsa', r'\.pem', r'\.key',
                r'password', r'secret', r'token'
            ]
            
            for layer in history:
                for pattern in sensitive_patterns:
                    if re.search(pattern, str(layer), re.IGNORECASE):
                        scan_result.vulnerabilities.append(
                            Vulnerability(
                                id=f"CONTAINER-002-{pattern}",
                                title="Potential sensitive data in image",
                                description=f"Layer may contain sensitive data matching: {pattern}",
                                severity=VulnerabilitySeverity.HIGH,
                                affected_component=image_name
                            )
                        )
                        break
                        
        except docker.errors.ImageNotFound:
            scan_result.errors.append(f"Image not found: {image_name}")
        except Exception as e:
            logger.warning(f"Image analysis failed: {e}")
    
    def _map_trivy_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map Trivy severity to our enum"""
        mapping = {
            'CRITICAL': VulnerabilitySeverity.CRITICAL,
            'HIGH': VulnerabilitySeverity.HIGH,
            'MEDIUM': VulnerabilitySeverity.MEDIUM,
            'LOW': VulnerabilitySeverity.LOW,
            'UNKNOWN': VulnerabilitySeverity.INFO
        }
        return mapping.get(severity.upper(), VulnerabilitySeverity.MEDIUM)
    
    def _extract_cvss_score(self, vuln: Dict) -> Optional[float]:
        """Extract CVSS score from vulnerability data"""
        if 'CVSS' in vuln:
            for source, data in vuln['CVSS'].items():
                if 'V3Score' in data:
                    return data['V3Score']
                elif 'V2Score' in data:
                    return data['V2Score']
        return None
    
    def _generate_scan_id(self) -> str:
        """Generate unique scan ID"""
        return hashlib.sha256(
            f"{datetime.utcnow().isoformat()}-container-{os.urandom(8).hex()}".encode()
        ).hexdigest()[:16]


class CodeSecurityScanner:
    """Scan source code for security vulnerabilities"""
    
    def __init__(self):
        self.scanners = {
            'bandit': self._scan_with_bandit,
            'semgrep': self._scan_with_semgrep,
            'secrets': self._scan_for_secrets
        }
    
    async def scan(self, project_path: Path) -> ScanResult:
        """Scan source code for vulnerabilities"""
        scan_result = ScanResult(
            scan_id=self._generate_scan_id(),
            scan_type=ScanType.CODE,
            start_time=datetime.utcnow(),
            target=str(project_path)
        )
        
        try:
            # Run multiple scanners
            await asyncio.gather(
                self._scan_with_bandit(project_path, scan_result),
                self._scan_with_semgrep(project_path, scan_result),
                self._scan_for_secrets(project_path, scan_result)
            )
            
        except Exception as e:
            scan_result.errors.append(f"Code scan error: {str(e)}")
            logger.error(f"Code scan error: {e}")
        
        scan_result.end_time = datetime.utcnow()
        return scan_result
    
    async def _scan_with_bandit(self, project_path: Path, scan_result: ScanResult):
        """Scan Python code with Bandit"""
        try:
            result = subprocess.run(
                ["bandit", "-r", str(project_path), "-f", "json"],
                capture_output=True,
                text=True
            )
            
            if result.stdout:
                bandit_results = json.loads(result.stdout)
                
                for issue in bandit_results.get('results', []):
                    scan_result.vulnerabilities.append(
                        Vulnerability(
                            id=f"BANDIT-{issue['test_id']}",
                            title=issue['test_name'],
                            description=issue['issue_text'],
                            severity=self._map_bandit_severity(issue['issue_severity']),
                            cwe_id=issue.get('cwe', {}).get('id'),
                            affected_component=f"{issue['filename']}:{issue['line_number']}",
                            references=[issue.get('more_info', '')]
                        )
                    )
        except Exception as e:
            logger.warning(f"Bandit scan failed: {e}")
    
    async def _scan_with_semgrep(self, project_path: Path, scan_result: ScanResult):
        """Scan code with Semgrep"""
        try:
            result = subprocess.run(
                ["semgrep", "--config=auto", "--json", str(project_path)],
                capture_output=True,
                text=True
            )
            
            if result.stdout:
                semgrep_results = json.loads(result.stdout)
                
                for finding in semgrep_results.get('results', []):
                    scan_result.vulnerabilities.append(
                        Vulnerability(
                            id=finding['check_id'],
                            title=finding.get('extra', {}).get('message', finding['check_id']),
                            description=finding.get('extra', {}).get('metadata', {}).get('description', ''),
                            severity=self._map_semgrep_severity(finding.get('extra', {}).get('severity', '')),
                            cwe_id=finding.get('extra', {}).get('metadata', {}).get('cwe'),
                            affected_component=f"{finding['path']}:{finding['start']['line']}",
                            references=finding.get('extra', {}).get('metadata', {}).get('references', [])
                        )
                    )
        except Exception as e:
            logger.warning(f"Semgrep scan failed: {e}")
    
    async def _scan_for_secrets(self, project_path: Path, scan_result: ScanResult):
        """Scan for hardcoded secrets"""
        try:
            # Using detect-secrets
            result = subprocess.run(
                ["detect-secrets", "scan", "--all-files", str(project_path)],
                capture_output=True,
                text=True
            )
            
            if result.stdout:
                secrets_results = json.loads(result.stdout)
                
                for filepath, secrets in secrets_results.get('results', {}).items():
                    for secret in secrets:
                        scan_result.vulnerabilities.append(
                            Vulnerability(
                                id=f"SECRET-{secret['type']}",
                                title=f"Hardcoded {secret['type']} detected",
                                description=f"Potential hardcoded secret found in {filepath}",
                                severity=VulnerabilitySeverity.HIGH,
                                affected_component=f"{filepath}:{secret['line_number']}"
                            )
                        )
        except Exception as e:
            logger.warning(f"Secret detection failed: {e}")
    
    def _map_bandit_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map Bandit severity"""
        mapping = {
            'HIGH': VulnerabilitySeverity.HIGH,
            'MEDIUM': VulnerabilitySeverity.MEDIUM,
            'LOW': VulnerabilitySeverity.LOW
        }
        return mapping.get(severity.upper(), VulnerabilitySeverity.MEDIUM)
    
    def _map_semgrep_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map Semgrep severity"""
        mapping = {
            'ERROR': VulnerabilitySeverity.HIGH,
            'WARNING': VulnerabilitySeverity.MEDIUM,
            'INFO': VulnerabilitySeverity.LOW
        }
        return mapping.get(severity.upper(), VulnerabilitySeverity.MEDIUM)
    
    def _generate_scan_id(self) -> str:
        """Generate unique scan ID"""
        return hashlib.sha256(
            f"{datetime.utcnow().isoformat()}-code-{os.urandom(8).hex()}".encode()
        ).hexdigest()[:16]


class InfrastructureScanner:
    """Scan infrastructure configuration for security issues"""
    
    async def scan_terraform(self, tf_path: Path) -> ScanResult:
        """Scan Terraform configurations"""
        scan_result = ScanResult(
            scan_id=self._generate_scan_id(),
            scan_type=ScanType.INFRASTRUCTURE,
            start_time=datetime.utcnow(),
            target=str(tf_path)
        )
        
        try:
            # Use tfsec for Terraform scanning
            result = subprocess.run(
                ["tfsec", str(tf_path), "--format", "json"],
                capture_output=True,
                text=True
            )
            
            if result.stdout:
                tfsec_results = json.loads(result.stdout)
                
                for issue in tfsec_results.get('results', []):
                    scan_result.vulnerabilities.append(
                        Vulnerability(
                            id=issue['rule_id'],
                            title=issue['rule_description'],
                            description=issue['description'],
                            severity=self._map_tfsec_severity(issue['severity']),
                            affected_component=f"{issue['location']['filename']}:{issue['location']['start_line']}",
                            references=[issue.get('link', '')]
                        )
                    )
        except Exception as e:
            logger.warning(f"tfsec scan failed: {e}")
        
        scan_result.end_time = datetime.utcnow()
        return scan_result
    
    async def scan_kubernetes(self, k8s_path: Path) -> ScanResult:
        """Scan Kubernetes configurations"""
        scan_result = ScanResult(
            scan_id=self._generate_scan_id(),
            scan_type=ScanType.INFRASTRUCTURE,
            start_time=datetime.utcnow(),
            target=str(k8s_path)
        )
        
        try:
            # Use kubesec for Kubernetes scanning
            for yaml_file in k8s_path.glob("**/*.yaml"):
                result = subprocess.run(
                    ["kubesec", "scan", str(yaml_file)],
                    capture_output=True,
                    text=True
                )
                
                if result.stdout:
                    kubesec_results = json.loads(result.stdout)
                    
                    for result in kubesec_results:
                        for issue in result.get('scoring', {}).get('critical', []):
                            scan_result.vulnerabilities.append(
                                Vulnerability(
                                    id=f"KUBESEC-CRITICAL",
                                    title=issue['selector'],
                                    description=issue['reason'],
                                    severity=VulnerabilitySeverity.CRITICAL,
                                    affected_component=str(yaml_file)
                                )
                            )
        except Exception as e:
            logger.warning(f"kubesec scan failed: {e}")
        
        scan_result.end_time = datetime.utcnow()
        return scan_result
    
    def _map_tfsec_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map tfsec severity"""
        mapping = {
            'CRITICAL': VulnerabilitySeverity.CRITICAL,
            'HIGH': VulnerabilitySeverity.HIGH,
            'MEDIUM': VulnerabilitySeverity.MEDIUM,
            'LOW': VulnerabilitySeverity.LOW
        }
        return mapping.get(severity.upper(), VulnerabilitySeverity.MEDIUM)
    
    def _generate_scan_id(self) -> str:
        """Generate unique scan ID"""
        return hashlib.sha256(
            f"{datetime.utcnow().isoformat()}-infra-{os.urandom(8).hex()}".encode()
        ).hexdigest()[:16]


class VulnerabilityScanner:
    """Main vulnerability scanning orchestrator"""
    
    def __init__(self, project_path: Path):
        self.project_path = project_path
        self.dependency_scanner = DependencyScanner()
        self.container_scanner = ContainerScanner()
        self.code_scanner = CodeSecurityScanner()
        self.infra_scanner = InfrastructureScanner()
        self.scan_history: List[ScanResult] = []
    
    async def run_full_scan(self) -> Dict[str, Any]:
        """Run comprehensive security scan"""
        logger.info("Starting comprehensive security scan")
        
        results = await asyncio.gather(
            self.dependency_scanner.scan(self.project_path),
            self.code_scanner.scan(self.project_path),
            self._scan_containers(),
            self._scan_infrastructure(),
            return_exceptions=True
        )
        
        # Process results
        scan_results = []
        for result in results:
            if isinstance(result, Exception):
                logger.error(f"Scan failed: {result}")
            elif isinstance(result, ScanResult):
                scan_results.append(result)
                self.scan_history.append(result)
            elif isinstance(result, list):
                scan_results.extend(result)
                self.scan_history.extend(result)
        
        # Generate report
        report = self._generate_report(scan_results)
        
        # Save report
        await self._save_report(report)
        
        return report
    
    async def _scan_containers(self) -> List[ScanResult]:
        """Scan all container images"""
        results = []
        
        # Scan images referenced in docker-compose
        compose_file = self.project_path / "docker-compose.yml"
        if compose_file.exists():
            with open(compose_file) as f:
                compose_data = yaml.safe_load(f)
            
            for service, config in compose_data.get('services', {}).items():
                if 'image' in config:
                    result = await self.container_scanner.scan_image(config['image'])
                    results.append(result)
        
        return results
    
    async def _scan_infrastructure(self) -> List[ScanResult]:
        """Scan infrastructure configurations"""
        results = []
        
        # Scan Terraform files
        tf_dir = self.project_path / "terraform"
        if tf_dir.exists():
            result = await self.infra_scanner.scan_terraform(tf_dir)
            results.append(result)
        
        # Scan Kubernetes files
        k8s_dir = self.project_path / "k8s"
        if k8s_dir.exists():
            result = await self.infra_scanner.scan_kubernetes(k8s_dir)
            results.append(result)
        
        return results
    
    def _generate_report(self, scan_results: List[ScanResult]) -> Dict[str, Any]:
        """Generate comprehensive security report"""
        total_vulns = sum(len(r.vulnerabilities) for r in scan_results)
        
        # Group vulnerabilities by severity
        severity_counts = defaultdict(int)
        for result in scan_results:
            for vuln in result.vulnerabilities:
                severity_counts[vuln.severity.value] += 1
        
        # Calculate risk score
        risk_score = self._calculate_risk_score(severity_counts)
        
        return {
            'report_id': hashlib.sha256(
                f"{datetime.utcnow().isoformat()}-report".encode()
            ).hexdigest()[:16],
            'scan_date': datetime.utcnow().isoformat(),
            'project_path': str(self.project_path),
            'summary': {
                'total_scans': len(scan_results),
                'total_vulnerabilities': total_vulns,
                'severity_breakdown': dict(severity_counts),
                'risk_score': risk_score,
                'risk_level': self._get_risk_level(risk_score)
            },
            'scan_results': [r.to_dict() for r in scan_results],
            'recommendations': self._generate_recommendations(scan_results),
            'compliance': self._check_compliance(scan_results)
        }
    
    def _calculate_risk_score(self, severity_counts: Dict[str, int]) -> float:
        """Calculate overall risk score (0-100)"""
        weights = {
            VulnerabilitySeverity.CRITICAL.value: 10,
            VulnerabilitySeverity.HIGH.value: 5,
            VulnerabilitySeverity.MEDIUM.value: 2,
            VulnerabilitySeverity.LOW.value: 1,
            VulnerabilitySeverity.INFO.value: 0.1
        }
        
        score = 0
        for severity, count in severity_counts.items():
            score += weights.get(severity, 0) * count
        
        # Normalize to 0-100
        return min(100, score)
    
    def _get_risk_level(self, risk_score: float) -> str:
        """Get risk level from score"""
        if risk_score >= 80:
            return "CRITICAL"
        elif risk_score >= 60:
            return "HIGH"
        elif risk_score >= 40:
            return "MEDIUM"
        elif risk_score >= 20:
            return "LOW"
        else:
            return "MINIMAL"
    
    def _generate_recommendations(self, scan_results: List[ScanResult]) -> List[Dict[str, Any]]:
        """Generate security recommendations"""
        recommendations = []
        
        # Analyze vulnerabilities
        all_vulns = []
        for result in scan_results:
            all_vulns.extend(result.vulnerabilities)
        
        # Group by component
        component_vulns = defaultdict(list)
        for vuln in all_vulns:
            component_vulns[vuln.affected_component].append(vuln)
        
        # Generate recommendations
        for component, vulns in component_vulns.items():
            critical_vulns = [v for v in vulns if v.severity == VulnerabilitySeverity.CRITICAL]
            if critical_vulns:
                recommendations.append({
                    'priority': 'CRITICAL',
                    'component': component,
                    'action': f"Immediately update {component} to fix {len(critical_vulns)} critical vulnerabilities",
                    'vulnerabilities': [v.id for v in critical_vulns]
                })
        
        # Add general recommendations
        if any(v.id.startswith("SECRET") for v in all_vulns):
            recommendations.append({
                'priority': 'HIGH',
                'component': 'Source Code',
                'action': 'Remove hardcoded secrets and use environment variables or secret management service'
            })
        
        return recommendations
    
    def _check_compliance(self, scan_results: List[ScanResult]) -> Dict[str, bool]:
        """Check compliance with security standards"""
        compliance = {
            'owasp_top_10': True,
            'cis_benchmarks': True,
            'pci_dss': True,
            'hipaa': True
        }
        
        # Check for specific vulnerability patterns
        all_vulns = []
        for result in scan_results:
            all_vulns.extend(result.vulnerabilities)
        
        # OWASP compliance checks
        if any(v.cwe_id in ['CWE-89', 'CWE-79', 'CWE-22'] for v in all_vulns):
            compliance['owasp_top_10'] = False
        
        # PCI DSS checks
        if any(v.id.startswith("SECRET") or "credit" in v.description.lower() for v in all_vulns):
            compliance['pci_dss'] = False
        
        return compliance
    
    async def _save_report(self, report: Dict[str, Any]):
        """Save security report"""
        report_dir = self.project_path / "security_reports"
        report_dir.mkdir(exist_ok=True)
        
        filename = f"security_report_{report['report_id']}.json"
        filepath = report_dir / filename
        
        async with aiofiles.open(filepath, 'w') as f:
            await f.write(json.dumps(report, indent=2))
        
        logger.info(f"Security report saved to: {filepath}")


# CI/CD Integration
class CICDSecurityIntegration:
    """Integrate security scanning into CI/CD pipeline"""
    
    def __init__(self, scanner: VulnerabilityScanner):
        self.scanner = scanner
    
    async def run_pipeline_scan(self, fail_on_severity: VulnerabilitySeverity = VulnerabilitySeverity.HIGH) -> bool:
        """Run scan suitable for CI/CD pipeline"""
        report = await self.scanner.run_full_scan()
        
        # Check if build should fail
        should_fail = False
        for severity in [VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH]:
            if severity.value in report['summary']['severity_breakdown']:
                if report['summary']['severity_breakdown'][severity.value] > 0:
                    if severity.score_range[0] >= fail_on_severity.score_range[0]:
                        should_fail = True
                        break
        
        # Generate output for CI/CD
        if should_fail:
            print(f"❌ Security scan failed - found vulnerabilities above {fail_on_severity.value} severity")
            print(f"Risk Score: {report['summary']['risk_score']}")
            print(f"Risk Level: {report['summary']['risk_level']}")
        else:
            print("✅ Security scan passed")
        
        # Output summary
        print("\nVulnerability Summary:")
        for severity, count in report['summary']['severity_breakdown'].items():
            print(f"  {severity}: {count}")
        
        return not should_fail


# Example usage
async def setup_vulnerability_scanner(project_path: Path):
    """Setup vulnerability scanner"""
    scanner = VulnerabilityScanner(project_path)
    
    # For CI/CD integration
    ci_integration = CICDSecurityIntegration(scanner)
    
    return scanner, ci_integration